

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The stream_graph.base.dataframes subpackage &mdash; Stream Graph 0.2 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../_static/_static/css/supplementary.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Getting Started" href="../auto_examples/index.html" />
    <link rel="prev" title="Choosing the optimal data-structure" href="ds1.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Stream Graph
          

          
            
            <img src="../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction/about.html">General Information</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/installation.html">Dependencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/installation.html#installing-dependencies">Installing Dependencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/installation.html#installing-the-master-version">Installing the master-version</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Package Walkthrough</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#theoretical-background">Theoretical Background</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#abstract-base-classes">Abstract Base Classes</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#data-structures">Data Structures</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="ds1.html">Choosing the optimal data-structure</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">The <code class="code docutils literal notranslate"><span class="pre">stream_graph.base.dataframes</span></code> subpackage</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-dataframe-operations">The dataframe operations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#merge"><code class="code docutils literal notranslate"><span class="pre">merge</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#union"><code class="code docutils literal notranslate"><span class="pre">union</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#intersection"><code class="code docutils literal notranslate"><span class="pre">intersection</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#difference"><code class="code docutils literal notranslate"><span class="pre">difference</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#issuperset"><code class="code docutils literal notranslate"><span class="pre">issuperset</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#nonempty-intersection"><code class="code docutils literal notranslate"><span class="pre">nonempty_intersection</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#cartesian-intersection"><code class="code docutils literal notranslate"><span class="pre">cartesian_intersection</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#map-intersection"><code class="code docutils literal notranslate"><span class="pre">map_intersection</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#interval-intersection-size"><code class="code docutils literal notranslate"><span class="pre">interval_intersection_size</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#algorithm-implementation">Algorithm implementation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Getting Started</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api.html">ABC Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html#base-classes">Base Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html#abc-implementations">ABC Implementations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html#temporal-dataframes">Temporal-DataFrames</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html#visualizer">Visualizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html#exceptions">Exceptions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stream Graph</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Package Walkthrough</a> &raquo;</li>
        
      <li>The <code class="code docutils literal notranslate"><span class="pre">stream_graph.base.dataframes</span></code> subpackage</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/package_walkthrough/ds2.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-stream-graph-base-dataframes-subpackage">
<h1>The <code class="code docutils literal notranslate"><span class="pre">stream_graph.base.dataframes</span></code> subpackage<a class="headerlink" href="#the-stream-graph-base-dataframes-subpackage" title="Permalink to this headline">¶</a></h1>
<p>At this section we will try to describe how we designed our core data-structures.
We defined 6 different variation of the dataframe, namely the:</p>
<ul class="simple">
<li>InstanraneousDF and InstantaneousWDF</li>
<li>CIntervalDF and CIntervalWDF</li>
<li>DIntervalDF and DIntervalWDF</li>
</ul>
<p>where ‘DF’ stands for DataFrame, ‘W’ for weighted, ‘C’ for continuous and ‘D’ for discrete.</p>
<p>In order to initialize the dataframe, the procedure is similar to pandas, with the difference that some time and weight columns names should be set to certain values in order to be recognizable: <code class="code docutils literal notranslate"><span class="pre">ts</span></code> for instantaneous, <code class="code docutils literal notranslate"><span class="pre">ts</span></code>, <code class="code docutils literal notranslate"><span class="pre">tf</span></code> for discrete intervals and <code class="code docutils literal notranslate"><span class="pre">ts</span></code>, <code class="code docutils literal notranslate"><span class="pre">tf</span></code>, <code class="code docutils literal notranslate"><span class="pre">s</span></code>, <code class="code docutils literal notranslate"><span class="pre">f</span></code> for continuous (where the <strong>boolean</strong> columns <code class="code docutils literal notranslate"><span class="pre">s</span></code>, <code class="code docutils literal notranslate"><span class="pre">f</span></code>, respectively signify if the start or the finish bound is closed). Moreover the weighted interval-data-frames should expect another column <code class="code docutils literal notranslate"><span class="pre">w</span></code> sigifying the weight of each entry.</p>
<p>Upon initialization the user should signify, if the data-frame (surely) has no overlapping elements in the time domain. This is possible through the boolean parameter parameter <code class="code docutils literal notranslate"><span class="pre">no_duplicates</span></code> in the case of instantaneous-data-frames and <code class="code docutils literal notranslate"><span class="pre">disjoint_intervals</span></code> in the case of interval-data-frames. If the time elements overlap a proccess called <code class="code docutils literal notranslate"><span class="pre">merge</span></code> (respectively for each case) will take place upon initialization, as in order for the other methods to function correcty <strong>the time-elements of common keys shouldn’t overlap</strong>.</p>
</div>
<div class="section" id="the-dataframe-operations">
<h1>The dataframe operations<a class="headerlink" href="#the-dataframe-operations" title="Permalink to this headline">¶</a></h1>
<p>In this basis a list of operations are defined common to all data-structures.
In all of them there is no change of the dimensionality of the data-frame.
Those who have the same dimensionality allow the result to be updated on self object, through an <code class="code docutils literal notranslate"><span class="pre">inplace</span></code> boolean parameter.</p>
<div class="section" id="merge">
<h2><code class="code docutils literal notranslate"><span class="pre">merge</span></code><a class="headerlink" href="#merge" title="Permalink to this headline">¶</a></h2>
<p>In its most general form merge can be defined as the operation that summarizes overlapping time elements on common keys.
On non-weighted elements multiple duplicate time-instants, will be reduced to a single instant.</p>
<p>For a continuous interval the rule is that two intervals <span class="math notranslate nohighlight">\((t_{s}^{a}, t_{f}^{a}, s^{a}, f^{a})\)</span> and <span class="math notranslate nohighlight">\((t_{s}^{b}, t_{f}^{b}, s^{b}, f^{b})`with :math:`t_{s}^{a} &lt;= t_{f}^{b}\)</span> are replaced by a common interval <span class="math notranslate nohighlight">\((t_{s}^{a}, t_{f}^{b}, s^{a}, f^{b})\)</span> iff <span class="math notranslate nohighlight">\(t_{f}^{a} &gt; t_{s}^{b}\)</span> lor (<span class="math notranslate nohighlight">\(t_{f}^{a} = t_{s}^{b}\land (f^{a}\;or\;s^{b}))\)</span>.</p>
<p>For a discrete interval the rule is that for two intervals <span class="math notranslate nohighlight">\((t_{s}^{a}, t_{f}^{a})\)</span>, <span class="math notranslate nohighlight">\((t_{s}^{b}, t_{f}^{b})\)</span> with <span class="math notranslate nohighlight">\(t_{s}^{a} \leq t_{f}^{b}\)</span> are replaced by a common interval <span class="math notranslate nohighlight">\((t_{s}^{a}, t_{f}^{b})\)</span> iff <span class="math notranslate nohighlight">\(t_{f}^{a} \geq t_{s}^{b} - 1\)</span>.
For weighted cases a merge-function is applied between all the weights assigned on each overlaping time-element. Intervals are then merged if they follow the above laws for each case, having the same weight.</p>
</div>
<div class="section" id="union">
<h2><code class="code docutils literal notranslate"><span class="pre">union</span></code><a class="headerlink" href="#union" title="Permalink to this headline">¶</a></h2>
<p>Similar to <code class="code docutils literal notranslate"><span class="pre">merge</span></code> but not identical in all cases, <code class="code docutils literal notranslate"><span class="pre">union</span></code> in its straight form takes two data-frames with common key-signature (for example such that both have the same keys with the same names <code class="code docutils literal notranslate"><span class="pre">u,</span> <span class="pre">v</span></code>) and for each common key it takes their union which has the same unordered rules in all cases, with <code class="code docutils literal notranslate"><span class="pre">merge</span></code>.</p>
<p>If weights exist the then we keep the weights of the first or of the second data-frame on non-overlapping time-elements respectively. On overlapping elements the weight is produced by union-function calculate between the two weights (as the two original dataframes are merged, there exist at-most two weights on overlap). Intervals then, that have the same-weight are then merged if they follow the above laws of merging interval.</p>
<p>To demonstrate a difference between a weighted case and not weighted one, please observe the union of the following example given that our union function is the sum <code class="code docutils literal notranslate"><span class="pre">+</span></code>.</p>
<p>Given <span class="math notranslate nohighlight">\(df_{a}\)</span>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="23%" />
<col width="15%" />
<col width="15%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">u</th>
<th class="head">v</th>
<th class="head">ts</th>
<th class="head">tf</th>
<th class="head">s</th>
<th class="head">f</th>
<th class="head">w</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>bee</td>
<td>flower</td>
<td>1</td>
<td>3</td>
<td>T</td>
<td>F</td>
<td>2</td>
</tr>
<tr class="row-odd"><td>bee</td>
<td>flower</td>
<td>3</td>
<td>5</td>
<td>T</td>
<td>T</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>and <span class="math notranslate nohighlight">\(df_b\)</span>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="23%" />
<col width="15%" />
<col width="15%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">u</th>
<th class="head">v</th>
<th class="head">ts</th>
<th class="head">tf</th>
<th class="head">s</th>
<th class="head">f</th>
<th class="head">w</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>bee</td>
<td>flower</td>
<td>1</td>
<td>3</td>
<td>T</td>
<td>F</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>bee</td>
<td>flower</td>
<td>3</td>
<td>5</td>
<td>T</td>
<td>T</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>their union <span class="math notranslate nohighlight">\(df_{ab}\)</span>, will be:</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="23%" />
<col width="15%" />
<col width="15%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">u</th>
<th class="head">v</th>
<th class="head">ts</th>
<th class="head">tf</th>
<th class="head">s</th>
<th class="head">f</th>
<th class="head">w</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>bee</td>
<td>flower</td>
<td>1</td>
<td>5</td>
<td>T</td>
<td>T</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="intersection">
<h2><code class="code docutils literal notranslate"><span class="pre">intersection</span></code><a class="headerlink" href="#intersection" title="Permalink to this headline">¶</a></h2>
<p>Intersection is in its most general form can be defined as the operation that keep the overlaps between time elements on common keys.
On non-weighted elements only duplicate time-instants, will be in the result of this method.</p>
<p>For a continuous interval the rule is that two intervals <span class="math notranslate nohighlight">\((t_{s}^{a}, t_{f}^{a}, s^{a}, f^{a})\)</span>, <span class="math notranslate nohighlight">\((t_{s}^{b}, t_{f}^{b}, s^{b}, f^{b})\)</span> with <span class="math notranslate nohighlight">\(t_{s}^{a} \neq t_{f}^{b}\)</span>, produce a valid interval <span class="math notranslate nohighlight">\(t_{s}^{i},\; t_{f}^{j},\; s_{i}\; if\; t_{s}^{a}\; \neq\; t_{s}^{b}\;else\;min(s^{a},\;s^{b}),\;f_{j}\;if\;t_{f}^{a} \neq t_{f}^{b}\;else\; min(f_{1}, f_{2})))\)</span>, where <span class="math notranslate nohighlight">\(argmax_{i}(t_{s}^{i}),\;argmax_{j}(t_{s}^{j})\)</span> <strong>iff</strong> <span class="math notranslate nohighlight">\(t_{f}^{a} &gt; t_{s}^{b}\lor (t_{f}^{a} = t_{s}^{b}\land f^{a}\land s^{b})\)</span>.</p>
<p>For a discrete interval the rule is that for two intervals <span class="math notranslate nohighlight">\((t_{s}^{a}, t_{f}^{a})\)</span> and <span class="math notranslate nohighlight">\((t_{s}^{b}, t_{f}^{b})`with :math:`t_{s}^{a} \leq t_{f}^{b}\)</span> are replaced by a common interval <span class="math notranslate nohighlight">\((t^{a}_{s}, t^{b}_{f})\)</span> iff <span class="math notranslate nohighlight">\(t_{f}^{a} \geq t_{s}^{b} - 1\)</span>.</p>
<p>For weighted cases a intersection-function is applied between the two weights occuring on each overlaping time-element. If this function returns a <code class="code docutils literal notranslate"><span class="pre">None</span></code> this time-element is ignored.</p>
</div>
<div class="section" id="difference">
<h2><code class="code docutils literal notranslate"><span class="pre">difference</span></code><a class="headerlink" href="#difference" title="Permalink to this headline">¶</a></h2>
<p>Difference is in its most general form, the binary operation that keeps the parts of the left data-frame that do not overlaps with the time elements of the second.
As so, on non-weighted elements only time-instants that only appear in the first dataframe will be in the result of this method.</p>
<p>For a continuous interval the rule is that two intervals <span class="math notranslate nohighlight">\((t_{s}^{a},\; t_{f}^{a},\;  s^{a},\; f^{a})\)</span> and <span class="math notranslate nohighlight">\((t_{s}^{b},\; t_{f}^{b},\; s^{b},\; f^{b})\)</span> with <span class="math notranslate nohighlight">\(t_{s}^{a} \leq t_{s}^{b}\)</span> <strong>or</strong> <span class="math notranslate nohighlight">\(t_{f}^{a} \leq t_{f}^{b}\)</span>, produce a valid interval <span class="math notranslate nohighlight">\((t_{s}^{a},\; t_{s}^{b},\; s^{a},\; \lnot s^{b})\)</span> <strong>or</strong> a valid interval <span class="math notranslate nohighlight">\((t_{f}^{a}, t_{f}^{b}, \lnot f^{a}, f^{b})\)</span> if <span class="math notranslate nohighlight">\(t_{s}^{a} &lt; t_{s}^{b}\lor (t_{s}^{a} = t_{s}^{b}\land s^{a} &gt; s^{b})\)</span> <strong>or</strong> if <span class="math notranslate nohighlight">\(t_{f}^{a} &gt; t_{f}^{b}\lor (t_{f}^{a} = t_{f}^{b}\land f^{a} &gt; f^{b})\)</span>.</p>
<p>In the discrete case the rule is that two intervals <span class="math notranslate nohighlight">\((t_{s}^{a},\; t_{f}^{a})\)</span> <span class="math notranslate nohighlight">\((t_{s}^{b},\; t_{f}^{b})\)</span> with <span class="math notranslate nohighlight">\(t_{s}^{a} \leq t_{s}^{b}\)</span> <strong>or</strong> <span class="math notranslate nohighlight">\(t_{f}^{a} \leq t_{f}^{b}\)</span>, produce a valid interval <span class="math notranslate nohighlight">\((t_{s}^{a}, t_{s}^{b} - 1)\)</span> <strong>or</strong> a valid interval <span class="math notranslate nohighlight">\((t_{f}^{a} + 1, t_{f}^{b})\)</span> if <span class="math notranslate nohighlight">\(t_{s}^{a} \leq t_{s}^{b} - 1\)</span> <strong>or</strong> if <span class="math notranslate nohighlight">\(t_{f}^{a} \geq t_{f}^{b} + 1\)</span>.</p>
<p>For weighted cases, the weights of the intervals of the first dataframe are conserved in non-overlapping time-elements. A difference-function is afterwards applied between the two weights occuring on each overlaping time-element. If this function returns a <code class="code docutils literal notranslate"><span class="pre">None</span></code> this time-element is ignored.</p>
</div>
<div class="section" id="issuperset">
<h2><code class="code docutils literal notranslate"><span class="pre">issuperset</span></code><a class="headerlink" href="#issuperset" title="Permalink to this headline">¶</a></h2>
<p>Issuperset in its most general form, is the boolean function that checks if all the elements of the second data-frame are all contained in the first another.
As so all time-instants of the second data-frame, should be contained in the first.</p>
<p>In the continuous case for each interval of the second data-frame <span class="math notranslate nohighlight">\((t_{s}^{b},\; t_{f}^{b},\; s^{b},\; f^{b})\)</span> there should exist an interval <span class="math notranslate nohighlight">\((t_{s}^{a},\; t_{f}^{a},\;  s^{a},\; f^{a})\)</span> in the first such that <span class="math notranslate nohighlight">\((t_{s}^{a} &lt; t_{s}^{b}\lor (t_{s}^{a} = t_{s}^{b}\land s^{a} \not &lt; s^{b}))\land (t_{f}^{a} &gt; t_{f}^{b}\lor (t_{f}^{a} = t_{f}^{b}\land f^{a} \not &lt; f^{b}))\)</span>.</p>
<p>In the discrete case for each interval of the second data-frame <span class="math notranslate nohighlight">\((t_{s}^{b},\; t_{f}^{b})\)</span> there should exist an interval <span class="math notranslate nohighlight">\((t_{s}^{a},\; t_{f}^{a})\)</span> in the first such that <span class="math notranslate nohighlight">\((t_{s}^{a} \leq t_{s}^{b}) and\;(t_{f}^{a} \geq t_{f}^{b})\)</span>.</p>
<p>For weighted cases, after satisfying the above conditions, a function is calculated between the weights of the container and the contained interval, which if it returns False for one occasion, the whole returns true.</p>
</div>
<div class="section" id="nonempty-intersection">
<h2><code class="code docutils literal notranslate"><span class="pre">nonempty_intersection</span></code><a class="headerlink" href="#nonempty-intersection" title="Permalink to this headline">¶</a></h2>
<p>This function checks if there the result of the intersection between two dataframes is not empty, following the laws of a valid intersection as defined above.
For weighted cases a function is defined such that an common-time element is accepted iff this function between the two associated weights returns True.</p>
<ul class="simple">
<li>Note: All the above operations (except merge) can be also called by having as a second element a dataframe without keys. When done so it is as if we apply this operation between all the time-elements associated with each key of the first data-frame and the time-elements of the second data-frame. This is possible by setting upon call of the method the argument <code class="code docutils literal notranslate"><span class="pre">by_key</span></code> to false.</li>
</ul>
</div>
<div class="section" id="cartesian-intersection">
<h2><code class="code docutils literal notranslate"><span class="pre">cartesian_intersection</span></code><a class="headerlink" href="#cartesian-intersection" title="Permalink to this headline">¶</a></h2>
<p>This function in a naive form takes two arguments that correspond to a temporal-link-set <span class="math notranslate nohighlight">\(L = U_{a} \times U_{b} \times T^{L}\)</span> and a TemporalNodeSet <span class="math notranslate nohighlight">\(N = V \times T^{N}\)</span>. First it calculates the cartesian product <span class="math notranslate nohighlight">\(CP = V_{a} \times V_{b} \times T^{CP}\)</span> on the vertices of the TemporalNodeSet, such that that for each two nodes <span class="math notranslate nohighlight">\(u, v \in V \times V\)</span>, <span class="math notranslate nohighlight">\(T_{u, v}^{CP} = T_{u}^{N} \cap T_{v} ^{N}\)</span>. The <em>cartesian intersection between</em> <span class="math notranslate nohighlight">\(L\)</span> and <span class="math notranslate nohighlight">\(N\)</span> is such <span class="math notranslate nohighlight">\(CI = (U_{a} \cap V) \times (U_{b} \cap V) \times T^{CI}\)</span>, such that if two nodes <span class="math notranslate nohighlight">\(u, v \in (U_{a} \cap V) \times (U_{b} \cap V)\)</span>, <span class="math notranslate nohighlight">\(T_{u, v}^{CP} = T_{u, v}^{L} \cap T_{u, v}^{CP} = T_{u, v}^{L} \cap T_{u}^{N} \cap T_{v} ^{N}\)</span>. This function is helpful for extracting the temporal-link-set defined inside a given temporal-node-set.</p>
<p>The rules of intersection of time-elements are the same with the intersection function.
In the weighted case a function taking three arguments is applied between a weight entry of the TemporalLinkSet and the weight entry of each of the other two corresponding nodes of the TemporalNodeSet.</p>
</div>
<div class="section" id="map-intersection">
<h2><code class="code docutils literal notranslate"><span class="pre">map_intersection</span></code><a class="headerlink" href="#map-intersection" title="Permalink to this headline">¶</a></h2>
<p>This function in a naive form, takes two arguments that correspond to a temporal-link-set <span class="math notranslate nohighlight">\(L = U_{a} \times U_{b} \times T^{L}\)</span> and a temporal-node-set <span class="math notranslate nohighlight">\(N = V \times T^{N}\)</span> and returns a temporal-node-set <span class="math notranslate nohighlight">\(TN = V^{TN} \times T^{TN}\)</span>, which corresponds to the <em>temporal neighborhood</em> of <span class="math notranslate nohighlight">\(N\)</span> in <span class="math notranslate nohighlight">\(L\)</span>. If we define with <span class="math notranslate nohighlight">\(N^{L}(u) = \{(v, t) : (u, v, t) \in L\}\)</span> and <span class="math notranslate nohighlight">\(N(u) = \{t: (u, t) \in V\}\)</span>
then the temporal-neighborhood of <span class="math notranslate nohighlight">\(N\)</span> in <span class="math notranslate nohighlight">\(L\)</span> and <span class="math notranslate nohighlight">\(TN = \cup_{u} \{(v, t):t \in N(u) \land (v, t) \in N^{L}(u) \}\)</span>.
By words it is the union of the non-by-key intersection of each time-set related to each node on the temporal-nodeset with the associated temporal-nodeset extracted from this node in the temporal-link-set: <span class="math notranslate nohighlight">\(\cup_{u} N^{L}(u) \cap_{\texttt{by_key=False}} N(u)\)</span>.
This operation has not until now been generalized to weighted cases, as we haven’t defined a weighted temporal-node-set.</p>
</div>
<div class="section" id="interval-intersection-size">
<h2><code class="code docutils literal notranslate"><span class="pre">interval_intersection_size</span></code><a class="headerlink" href="#interval-intersection-size" title="Permalink to this headline">¶</a></h2>
<p>Based on the rules previously defined, this function calculates the size of the intersection between two-dataframes. As mentioned before, in the continuous case the size of a continuous interval <span class="math notranslate nohighlight">\((t_{s}^{a},\; t_{f}^{a},\;  s^{a},\; f^{a})\)</span> is equal to <span class="math notranslate nohighlight">\(t_{f}^{a} - t_{s}^{a}\)</span>. In the discrete case the size of an interval <span class="math notranslate nohighlight">\((t_{s}^{a},\; t_{f}^{a})\)</span> is equal to <span class="math notranslate nohighlight">\(t_{f}^{a} - t_{s}^{a} + 1\)</span>. In the case of instants as size exists only in the discrete case, this function counts in general the number of common time-elements.</p>
<p>In the weigted case, a function is applied between two collections of weighted elements from the first data-frame and of weighted elements of the second data-frame, which coexist at the same time elements.</p>
</div>
<div class="section" id="algorithm-implementation">
<h2>Algorithm implementation<a class="headerlink" href="#algorithm-implementation" title="Permalink to this headline">¶</a></h2>
<p>Without going into much detail, we will try to describe our basic algorithmic design, which is common in all of the above algorithms.
We would first like to emphasize to algorithms, that concern intervals.
All interval elements can be deconstructed in what we call <em>events</em>. Instead of having the interval [2, 3], what we can have is two events (2, True), (3, False) signifying that an interval starts and an interval finishes. Moreover a signifier, which is refered inside the code as <em>reference</em> (boolean as we have two) can optionally describe to which of category an interval belongs.
Later each algorithm can be constructed, such that based in a certain ordering on equivalent occurencies of ascending time (and following the assumption that each interval is valid and in some cases that the orignal intervals in each data-frame are merged) a function is executed which considering some previous information stored in what we call <em>a cache</em> stored for each active key (if we have keys) updates this information or outputs a part of the result (value or interval).
All this algorithms can be found in <code class="code docutils literal notranslate"><span class="pre">stream_graph.base.dataframes.algorithms</span></code>, while there exists a big amount of orderings which change concerning its <em>update</em> function.
These orderings take into account a certain form of events (defined in <code class="code docutils literal notranslate"><span class="pre">stream_graph.base.dataframes.algorithms.utils.{no_bounds,</span> <span class="pre">bounds}</span></code>) and are all base on ascending time, while having a different ordering deppending on the type of the bound and the reference if they exist and the start.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../auto_examples/index.html" class="btn btn-neutral float-right" title="Getting Started" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ds1.html" class="btn btn-neutral" title="Choosing the optimal data-structure" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, LIP6

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'0.2',
              LANGUAGE:'en',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>